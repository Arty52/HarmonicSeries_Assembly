     1                                  ;Author information
     2                                  ;  Author name: Art Grichine
     3                                  ;  Author email: ArtGrichine@gmail.com
     4                                  ;Course information
     5                                  ;  Course number: CPSC240
     6                                  ;  Assignment number: 6
     7                                  ;  Due date: 2014-May-08
     8                                  ;Project information
     9                                  ;  Project title: Harmonic Series (Assignment 6)
    10                                  ;  Purpose: Preform summation of harmonic series until the user's input is less than or equal to the sum and return the number of
    11                                  ;		terms added. The number of terms added, clock speed (pre/post calc) are returned to the user.
    12                                  ;  Status: No known errors
    13                                  ;  Project files: harmoniceuler_driver.cpp, harmoniceuler.asm, debug.inc, debug.asm
    14                                  ;Module information
    15                                  ;  This module's call name: harmoniceuler
    16                                  ;  Language: X86-64
    17                                  ;  Syntax: Intel
    18                                  ;  Date last modified: 2014-May-07
    19                                  ;  Purpose: This module takes a users input and uses Euler's constant and taylor series to calculate the number of terms needed to
    20                                  ;		be greater than or equal to the user's input. This is a Ultra Fast processing method opposed to the brute force add.
    21                                  ;  File name: harmoniceuler.asm
    22                                  ;  Status: In production.  No known errors.
    23                                  ;  Future enhancements: 'ldmxcsr' in the 'output results section is commented out. In this program the 'cvtsd2si' rounding should
    24                                  ;				always get the ceiling of the FPU number however the standard setting for this is to round up when
    25                                  ;				# > .5 and down if # < .5 (conventional rounding rules). 'ldmxcsr' is 'Load Streaming SIMD Extension 
    26                                  ;				Control/Status', bits 13 and 14 act as round control. See: http://www.jaist.ac.jp/iscenter-new/mpc/
    27                                  ;				altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/
    28                                  ;				reference_olh/mergedProjects/instructions/instruct32_hh/vc148.htm
    29                                  ;				for more information. At the moment the error of this program is +/- 1 (much better than vector
    30                                  ;				processing error of at least +/- 4).
    31                                  ;Translator information
    32                                  ;  Assemble: nasm -f elf64 -l harmoniceuler.lis -o harmoniceuler.o harmoniceuler.asm
    33                                  ;References and credits
    34                                  ;  CSUF/Professor Floyd Holliday: http://holliday.ecs.fullerton.edu
    35                                  ;Print information
    36                                  ;  Page width: 132 columns
    37                                  ;  Begin comments: 65
    38                                  ;  Optimal print specification: Landscape, 9 points or smaller, monospace, 8Â1⁄2x11 paper
    39                                  ;Notes:
    40                                  ;  Formula used in this program is derived at the very bottom of the document. It is refered to in the code and the explination of 
    41                                  ;	the derivation of this formula is found at the very end.
    42                                  ;  Maximum sum tested is 44.2
    43                                  ;	"The harmonic computation required 44232 clock cycles (tics) which is 17012.3 ns or 0.00001701 seconds." <-- THATS FAST!
    44                                  ;    	"The harmonic sum is 44.20, which required the addition of 8813218186917735424 terms."
    45                                  ;  The largest signed integer on a 64-bit CPU is 2^63 - 1 = 922337203685477807, exceeding this # will cause overflow. See note below
    46                                  ;  Exceding 44.2 causes the integer register to max out and the number is no longer valid:
    47                                  ;	example:
    48                                  ;		The harmonic sum is 44.30, which required the addition of -9223372036854775808 terms.
    49                                  ;===== Begin code area ============================================================================================================
    50                                  
    51                                  %include "debug.inc" 					    ;This file contains the subprogram to be tested with this test program.
    52                              <1> ;System Title:  Debugger for X86 assembly programs
    53                              <1> ;Author: Floyd Holliday
    54                              <1> ;Email: activeprofessor@yahoo.com
    55                              <1> ;Status: Released for general use; bugs will be fixed when reported
    56                              <1> ;This module file name: debug.inc
    57                              <1> ;This module purpose: This file is an "include" file.  It allows data to pass directly from the calling statement to the subprogram.
    58                              <1> ;Language: X86
    59                              <1> ;Syntax: Intel
    60                              <1> ;Date of last update: 2013-Dec-13
    61                              <1> ;Source file structure: width is 140 characters; detailed comments begin in column 61.
    62                              <1> ;Printing: best results are obtained using landscape orientation with 9 point (or less) monospaced font.
    63                              <1> ;
    64                              <1> ;Targeted user group: Assembly programmers enrolled in programming courses like CPSC240.
    65                              <1> ;
    66                              <1> ;Requirements: debug.asm must be assembled into debug.o  This file is not to be assembled; it is used as is.  Place this file in the 
    67                              <1> ;directory along with debug.o and with other assembled object files.
    68                              <1> ;
    69                              <1> 
    70                              <1> ;===== showregisters ======================================================================================================================
    71                              <1> 
    72                              <1> extern showregisterssubprogram
    73                              <1> 
    74                              <1> %macro showregisters 1
    75                              <1>     push qword %1
    76                              <1>     call showregisterssubprogram
    77                              <1>     ;Question: Where is the pop corresponding to the push above?  Answer: In the ret statement.
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> ;===== showstack ==========================================================================================================================
    81                              <1> 
    82                              <1> extern showstacksubprogram
    83                              <1> 
    84                              <1> %macro dumpstack 3
    85                              <1>     push rsp                                      ;Save the current value of rsp since rsp is very volatile
    86                              <1>     push rbp                                      ;Save the current value of rbp for insurance
    87                              <1>     push qword %3                                 ;number of qwords inside the stack
    88                              <1>     push qword %2                                 ;number of qwords outside the stack
    89                              <1>     push qword %1                                 ;an arbitrary integer created by the caller
    90                              <1>     call showstacksubprogram
    91                              <1>     ;Question: Where are the pops corresponding to three pushes above?  Answer: In the ret statement.
    92                              <1> %endmacro
    93                              <1> 
    94                              <1> ;===== showfpu ============================================================================================================================
    95                              <1> 
    96                              <1> extern showfpusubprogram
    97                              <1> 
    98                              <1> %macro showfpuregisters 1
    99                              <1>     push qword %1                                 ;Integer identifying this showing of the fpu registers.
   100                              <1>     call showfpusubprogram
   101                              <1>     ;Where are the pops corresponding to those pushes?
   102                              <1> %endmacro
   103                              <1> 
   104                              <1> ;===== showxmm ============================================================================================================================
   105                              <1> 
   106                              <1> extern showxmmsubprogram
   107                              <1> 
   108                              <1> %macro showxmmregisters 1
   109                              <1>      push qword %1
   110                              <1>      call showxmmsubprogram
   111                              <1> %endmacro
   112                              <1> 
   113                              <1> ;===== showymm ============================================================================================================================
   114                              <1> 
   115                              <1> extern showymmsubprogram
   116                              <1> 
   117                              <1> %macro showymmregisters 1
   118                              <1>     push qword %1
   119                              <1>     call showymmsubprogram
   120                              <1> %endmacro
   121                              <1> 
   122                              <1> ;==========================================================================================================================================
   123                              <1> 
   124                              <1> ;How to use the debugger.
   125                              <1> 
   126                              <1> ;1.  Assemble the file debug.asm and thereby create an object file known as debug.o
   127                              <1> 
   128                              <1> ;2.  Place into one single directory this file, debug.inc, and debug.o, and as many addition source file as desired.
   129                              <1> 
   130                              <1> ;3.  Insert the statement < %include "debug.inc" > without angle brackets into an asm source file to be debugged.  Place the statement 
   131                              <1> ;    before segment .data .
   132                              <1> 
   133                              <1> ;4.  In segment .text place debugging statements at places where you want to examen the contents of registers.  There are four kinds 
   134                              <1> ;    of debug statements, namely: show the integer registers, show the system stack, show the fpu registers, and show the SSE2 
   135                              <1> ;    registers.  Examples of each of the four kinds of debug statements are found below.
   136                              <1> 
   137                              <1> ;Example of debug statememts.
   138                              <1> 
   139                              <1> ;==============================================
   140                              <1> ;  showregisters 33
   141                              <1> ;==============================================
   142                              <1> ;The statement above will show the contents of all 16 integer registers and the contents of the flags register.  The trailing number 33 
   143                              <1> ;is arbitrary.  The number 33 in the example can be replaced with any integer, but it cannot be omitted.
   144                              <1> 
   145                              <1> ;==============================================
   146                              <1> ;  dumpstack 88, 2, 5
   147                              <1> ;==============================================
   148                              <1> ;The statement above will show the contents the system stack beginning with 2 quadwords outside of the top of the stack and ending with
   149                              <1> ;quadword #5 inside the stack for a total of 8 quadwords.  The first parameter 88 is an arbitrary integer selected by the programmer.
   150                              <1> ;The second parameter 2 indicates the number of quadwords beyond the top to be displayed.  To display nothing outside of the stack set
   151                              <1> ;the middle parameter to 0.  The last parameter 5 is the number of qwords after the top to be display.  The count is from 0 to 5, and
   152                              <1> ;therefore, a 5 parameter will cause 6 qwords inside the stack to be outputted.
   153                              <1> 
   154                              <1> ;==============================================
   155                              <1> ;  showfpuregisters 133
   156                              <1> ;==============================================
   157                              <1> ;The statement above will show the contents of all 8 fpu registers.  The parameter 133 is arbitrary and may be replaced by any integer,
   158                              <1> ;but it cannot be omitted.
   159                              <1> 
   160                              <1> ;==============================================
   161                              <1> ;  showxmmregisters 888
   162                              <1> ;==============================================
   163                              <1> ;The statement above will show the contents of all 16 SSE2 registers.  The parameter 888 is arbitrary and may be replaced by any integer,
   164                              <1> ;but it cannot be omitted.
   165                              <1> 
   166                              <1> ;==============================================
   167                              <1> ;  showymmregisters 225
   168                              <1> ;==============================================
   169                              <1> ;The statement above will show the contents of all 16 AVE registers.  The parameter 225 is arbitrary and may be replaced by any integer,
   170                              <1> ;but it cannot be omitted.
   171                              <1> 
   172                              <1> 
   173                              <1> 
   174                              <1> 
   175                              <1> ;To the 240 class:
   176                              <1> ;This debug set of subprograms was derived from the original work of Dr Paul Carter.  He made a similar set of subprograms that could 
   177                              <1> ;be easily included in any assembly program.  All of his work was written in X86-32m and unfortunately, he seems to have lost interest 
   178                              <1> ;in updating his work.  You can and probably should visit his website: http://www.drpaulcarter.com/pcasm/.  There you may download the
   179                              <1> ;original include files which he called "asm_io.inc" and "asm_io.asm".  They are inside a zip file.  He also has a free ebook there on 
   180                              <1> ;X86-32 programming.  Yes, all the examples are 32-bit one, but the text description of instructions is still very helpful.  For 
   181                              <1> ;instance, in his ebook you can read a concise description of many of the FPU87 instructions, that is, those instructions that act on
   182                              <1> ;the st registers.  Yes, I am aware that others have tried to update his work to become relevant to 64-bit programming, but I still like
   183                              <1> ;the original ebook.
   184                              <1> 
   185                              <1> ;Thus, Dr Carter's work was the foundation for the debug.inc and debug.asm files you are now reading.  For the curious, you may wonder 
   186                              <1> ;what happens when an assembly program has to call a C++ function that requires more that 6 incoming parameters.  There is an example of
   187                              <1> ;passing 9 parameters to printf in the "showregisterssubprogram", which is inside the file debug.asm.  Notice the registerformat1 requires 8 numeric
   188                              <1> ;values be passed to printf in addition to passing the string registerformat1 in rdi.  
   189                              <1> 
   190                              <1> 
   191                              <1> 
   192                                  
   193                                  extern printf						    ;External C++ function for writing to standard output device
   194                                  
   195                                  extern scanf						    ;External C++ function for obtaining user input
   196                                  
   197                                  global harmonicseries	 				    ;This makes 'harmonicseries' callable by functions outside of this file.
   198                                  
   199                                  segment .data						    ;Place initialized data here
   200                                  
   201                                  ;===== Message Declarations =======================================================================================================
   202                                  
   203 00000000 0A57656C636F6D6520-     welcome db 10, "Welcome to harmonic series by Art Grichine!", 10,
   204 00000009 746F206861726D6F6E-
   205 00000012 696320736572696573-
   206 0000001B 206279204172742047-
   207 00000024 72696368696E65210A 
   208 0000002D 0A5468652070726F67-     	db 10, "The program will compute a partial sum of the harmonic series.", 10,
   209 00000036 72616D2077696C6C20-
   210 0000003F 636F6D707574652061-
   211 00000048 207061727469616C20-
   212 00000051 73756D206F66207468-
   213 0000005A 65206861726D6F6E69-
   214 00000063 63207365726965732E-
   215 0000006C 0A                 
   216 0000006D 0A5468657365207265-             db 10, "These results were obtained on a MacBook Pro (late 2013) running Haswell i7 at 2.6GHz.", 10, 0
   217 00000076 73756C747320776572-
   218 0000007F 65206F627461696E65-
   219 00000088 64206F6E2061204D61-
   220 00000091 63426F6F6B2050726F-
   221 0000009A 20286C617465203230-
   222 000000A3 3133292072756E6E69-
   223 000000AC 6E672048617377656C-
   224 000000B5 6C2069372061742032-
   225 000000BE 2E3647487A2E0A00   
   226                                  
   227 000000C6 0A506C656173652065-     enter_number_x db 10, "Please enter a positive real number X: ", 0 
   228 000000CF 6E746572206120706F-
   229 000000D8 736974697665207265-
   230 000000E1 616C206E756D626572-
   231 000000EA 20583A2000         
   232                                  
   233 000000EF 54686520736D616C6C-     sum_being_computed db "The smallest harmonic sum ≥ X is being computed.", 10, 0
   234 000000F8 657374206861726D6F-
   235 00000101 6E69632073756D20E2-
   236 0000010A 89A520582069732062-
   237 00000113 65696E6720636F6D70-
   238 0000011C 757465642E0A00     
   239                                  
   240 00000123 506C65617365206265-     be_patient db "Please be patient . . . . The sum is now computed.", 10, 0
   241 0000012C 2070617469656E7420-
   242 00000135 2E202E202E202E2054-
   243 0000013E 68652073756D206973-
   244 00000147 206E6F7720636F6D70-
   245 00000150 757465642E0A00     
   246                                  
   247 00000157 546865206861726D6F-     results db "The harmonic sum is %1.2lf, which required the addition of %ld terms.", 10, 0
   248 00000160 6E69632073756D2069-
   249 00000169 732025312E326C662C-
   250 00000172 207768696368207265-
   251 0000017B 717569726564207468-
   252 00000184 65206164646974696F-
   253 0000018D 6E206F6620256C6420-
   254 00000196 7465726D732E0A00   
   255                                  
   256 0000019E 54686520636C6F636B-     system_clock_pre db "The clock time before the calculations began was %ld.", 10, 0
   257 000001A7 2074696D6520626566-
   258 000001B0 6F7265207468652063-
   259 000001B9 616C63756C6174696F-
   260 000001C2 6E7320626567616E20-
   261 000001CB 77617320256C642E0A-
   262 000001D4 00                 
   263                                  
   264 000001D5 54686520636C6F636B-     system_clock_post db "The clock time after completion of calculations was %ld.", 10, 0
   265 000001DE 2074696D6520616674-
   266 000001E7 657220636F6D706C65-
   267 000001F0 74696F6E206F662063-
   268 000001F9 616C63756C6174696F-
   269 00000202 6E732077617320256C-
   270 0000020B 642E0A00           
   271                                  
   272 0000020F 546865206861726D6F-     elapsed_time db "The harmonic computation required %5ld clock cycles (tics) which is %7.1lf ns or %1.8lf seconds.", 10, 0
   273 00000218 6E696320636F6D7075-
   274 00000221 746174696F6E207265-
   275 0000022A 717569726564202535-
   276 00000233 6C6420636C6F636B20-
   277 0000023C 6379636C6573202874-
   278 00000245 696373292077686963-
   279 0000024E 682069732025372E31-
   280 00000257 6C66206E73206F7220-
   281 00000260 25312E386C66207365-
   282 00000269 636F6E64732E0A00   
   283                                  
   284 00000271 546869732061737365-     return_to_caller db "This assembly program will return to the caller.", 10, 0
   285 0000027A 6D626C792070726F67-
   286 00000283 72616D2077696C6C20-
   287 0000028C 72657475726E20746F-
   288 00000295 207468652063616C6C-
   289 0000029E 65722E0A00         
   290                                  
   291 000002A3 257300                  stringformat db "%s", 0						;general string format
   292                                  
   293 000002A6 256C6600                formatOneFloat db "%lf", 0					;this format will absorb Taylor Series input of float type 64-bit
   294                                  
   295                                  segment .bss							;Place un-initialized data here.
   296                                  
   297                                          ;This segment is empty
   298                                  
   299                                  segment .text							;Place executable instructions in this segment.
   300                                  
   301                                  harmonicseries:							;Entry point.  Execution begins here.
   302                                  
   303                                  ;=========== Back up all the integer registers used in this program ===============================================================
   304                                  
   305 00000000 55                      push rbp 							;Backup the stack base pointer
   306 00000001 4889E5                  mov  rbp, rsp							;copy stack on rbp to ensure proper restoration when program is done
   307 00000004 57                      push rdi 							;Backup the destination index
   308 00000005 56                      push rsi 							;Backup the source index
   309 00000006 52                      push rdx							;Backup the register
   310 00000007 51                      push rcx							;Backup the register
   311 00000008 4150                    push r8								;Backup the register
   312 0000000A 4151                    push r9								;Backup the register
   313 0000000C 4152                    push r10							;Backup the register
   314 0000000E 4153                    push r11							;Backup the register
   315 00000010 4154                    push r12							;Backup the register
   316 00000012 4155                    push r13							;Backup the register
   317 00000014 4156                    push r14							;Backup the register
   318 00000016 4157                    push r15							;Backup the register	
   319                                  
   320                                  ;============  Preliminary ========================================================================================================
   321                                  
   322 00000018 C5FC77                  vzeroall							;zeros out all SSE registers
   323                                  
   324                                  ;=========== Initialize divider register ==========================================================================================
   325                                  								;for our calculations we must set 4 SSE registry's to 1.0 to 
   326                                  								;accomidate for our algorithm: count, nth term, accum, incrimentor
   327 0000001B 48B8000000000000F0-     mov  rax, 0x3ff0000000000000 					;copy HEX 1.0 value onto rax
   328 00000024 3F                 
   329 00000025 50                      push rax							;push rax value onto the stack for broadcast operation
   330 00000026 C4627D190424            vbroadcastsd ymm8,  [rsp]					;this will be our incrimentor used to add to count
   331 0000002C C4627D191424            vbroadcastsd ymm10, [rsp]					;makes ymm10 all 1.0, this will be our count
   332 00000032 C4627D191C24            vbroadcastsd ymm11, [rsp]					;makes ymm9 all 1.0, this will hold our nth term
   333 00000038 C4627D192424            vbroadcastsd ymm12, [rsp]					;makes ymm8 all 1.0, this will be our accumulator
   334 0000003E 58                      pop  rax							;push operand must be followed by a pop operation when complete
   335                                  
   336                                  ;=========== Show the initial message =============================================================================================
   337                                  
   338 0000003F 4831C0                  xor  rax, rax							;tell printf not to expect any doubles in upcoming call
   339 00000042 48BF-                   mov  rdi, stringformat 						;simple format indicating string ' "%s",0 '
   340 00000044 [A302000000000000] 
   341 0000004C 48BE-                   mov  rsi, welcome 						;display: Welcome Message, Name, Machine, Purpose of Assignment 
   342 0000004E [0000000000000000] 
   343 00000056 E8(00000000)            call printf							;display welcome message from the driver program (.cpp)
   344                                  
   345                                  ;============ Input for X value ===================================================================================================
   346                                  
   347                                  ;==== Display message for x ====
   348 0000005B 4831C0                  xor  rax, rax							;satisfies printf function, expects no doubles in upcoming printf
   349 0000005E 48BF-                   mov  rdi, stringformat						;"%s"
   350 00000060 [A302000000000000] 
   351 00000068 48BE-                   mov  rsi, enter_number_x 					;"Please enter a positive real number X: "
   352 0000006A [C600000000000000] 
   353 00000072 E8(00000000)            call printf							;display user prompt for 'x' values
   354                                  
   355                                  ;==== Grab data for x ====
   356 00000077 4831C0                  xor  rax, rax							;clear rax registry
   357 0000007A 6A00                    push qword 0							;allocate storage for an input number on int stack
   358 0000007C 48BF-                   mov  rdi, formatOneFloat 					;formats input of scanf to recieve a float number "%lf"
   359 0000007E [A602000000000000] 
   360 00000086 4889E6                  mov  rsi, rsp							;assign register to copy stack pointer location to absorb X
   361 00000089 E8(00000000)            call scanf							;scan user input for 'x'
   362 0000008E C57D103C24              vmovupd ymm15, [rsp] 						;place user X value onto ymm15 for upcoming comparison
   363 00000093 58                      pop rax								;deallocate memory allocation for input
   364                                  
   365                                  ;==== computation starting message ====
   366 00000094 4831C0                  xor  rax, rax							;tell printf not to expect any doubles in upcoming call
   367 00000097 48BF-                   mov  rdi, stringformat 						;simple format indicating string ' "%s",0 '
   368 00000099 [A302000000000000] 
   369 000000A1 48BE-                   mov  rsi, sum_being_computed					;display: "The smallest harmonic sum ≥ X is being computed.", 10, 0
   370 000000A3 [EF00000000000000] 
   371 000000AB E8(00000000)            call printf							;display message from the driver program (.cpp)
   372                                  
   373                                  ;============ Read system clock pre-calculations===================================================================================
   374                                  								;System clock-speed found in 1/2 of rdx and 1/2 of rax, to get the
   375                                  								;accurate clock-speed (in tics) we must read the clock and then 
   376                                  								;combine the two registers (rdx:rax) into one for the full reading. 
   377                                  ;==== get system clock ====
   378 000000B0 0FA2                    cpuid								;stop 'look ahead' for cpu; lets us get a more accurate clock speed
   379 000000B2 0F31                    rdtsc								;read cpu clock, values stored in rdx:rax
   380 000000B4 41BD00000000            mov qword r13, 0						;zero out r13 register for upcoming calculations, will hold rax
   381 000000BA 41BC00000000            mov qword r12, 0						;zero out r12 register for upcoming calculations, will hold rdx
   382 000000C0 4989C5                  mov 	  r13, rax						;place rdx value onto r13 in preparation to combine rax/rdx
   383 000000C3 4989D4                  mov 	  r12, rdx						;place rdx value onto r12 in preparation to combine rax/rdx
   384 000000C6 49C1E420                shl	  r12, 32						;shift r12 32 bits
   385 000000CA 4D09EC                  or	  r12, r13						;combine r12 and r13, r12 has entire system clock count now 
   386                                  
   387                                  ;============ Calculate Harmonic Sum ==============================================================================================
   388                                  								;In our computation we must solve for 'n' with the derived formula:
   389                                  								;  n = e ^ (x - eulers constant).  Derivation of this formula is 
   390                                  								;  attached to the bottom of this document.							
   391                                  
   392                                  ;==== Place Euler's constant on SSE ====
   393 000000CD 48B819B66FFC8C78E2-     mov  rax, 0x3fe2788cfc6fb619					;HEX FOR EULER'S CONSTANT: 0x3fe2788cfc6fb619 = about 0.577,
   394 000000D6 3F                 
   395                                  								;  however the value displayed in hex is exact euler to 64 bits
   396 000000D7 50                      push rax							;place Euler's constant on stack
   397 000000D8 F2440F103424            movsd xmm14, [rsp]						;place Euler's constant on SSE registery for FPU calculations
   398 000000DE 58                      pop rax								;return stack pointer to location before previous 4 instructions
   399                                  
   400                                  ;==== Control precision of Taylor series e^x ====
   401 000000DF 41B864000000            mov      r8, 100						;select integer value to control accuracy of taylor series calc
   402                                  								;  100 Taylor iterations gives us more than enough accuracy
   403 000000E5 F24D0F2AC8              cvtsi2sd xmm9, r8						;convert comparison number to FPU and place on SSE for loop
   404 000000EA F2450F10EF              movsd  	 xmm13, xmm15						;place user input on new register for computation
   405 000000EF F2450F5CEE              subsd    xmm13, xmm14						;(x - euler's constant)
   406                                  
   407                                  ;==== computation with Eulers constant ====
   408                                  iterate_again:							;iterate through until xmm12(count) is =to xmm9 (our taylor series)
   409 000000F4 C4412559DD              vmulpd ymm11, ymm13						;x^n
   410 000000F9 C441255EDC              vdivpd ymm11, ymm12						;(x^n)/n!
   411 000000FE C4412D58D3              vaddpd ymm10, ymm11						;1 + (x^n)/n! + (x^n+1)/(n+1)! + etc...
   412                                  
   413 00000103 66450F2EE1              ucomisd xmm12, xmm9						;compare count (xmm12) with our users Taylor Series number (xmm9)
   414 00000108 C4411D58E0              vaddpd  ymm12, ymm8						;increment count by 1.0
   415 0000010D 72E5                    jb iterate_again						;if xmm12 < xmm9 jump to 'iterate_again:' jb is 'jumb below', if
   416                                  								;  we wanted to compare xmm12 > xmm9 we would use ja 'jumb above'
   417                                  
   418                                  ;============ Read system clock post-calculations==================================================================================
   419                                  
   420                                  ;==== get system clock ====
   421 0000010F 0FA2                    cpuid								;stop 'look ahead' for cpu
   422 00000111 0F31                    rdtsc								;read cpu clock, values stored in rdx:rax
   423 00000113 41BF00000000            mov qword r15, 0						;zero out r15 register for upcoming calculations, will hold rax
   424 00000119 41BE00000000            mov qword r14, 0						;zero out r14 register for upcoming calculations, will hold rdx
   425 0000011F 4989C7                  mov 	  r15, rax						;place rax value onto r15 in preparation to combine rax/rdx
   426 00000122 4989D6                  mov 	  r14, rdx						;place rdx value onto r14 in preparation to combine rax/rdx
   427 00000125 49C1E620                shl	  r14, 32						;shift r14 32 bits
   428 00000129 4D09FE                  or	  r14, r15						;combine r14 and r15, r14 has entire system clock count now
   429                                  				
   430                                  ;==== output system clock pre-calc ====
   431 0000012C 4C89E6                  mov rsi, r12							;place timer value from rax into rsi in preperation for output
   432 0000012F 4831C0                  xor rax, rax							;zero-out rax register
   433 00000132 48BF-                   mov rdi, system_clock_pre					;assign output format to rdi for printf output
   434 00000134 [9E01000000000000] 
   435 0000013C E8(00000000)            call printf							;print system clock tics pre-calculation
   436                                  							
   437                                  ;==== output system clock post-calc ====
   438 00000141 4C89F6                  mov rsi, r14							;place timer value from rax into rsi in preperation for output
   439 00000144 4831C0                  xor rax, rax							;zero-out rax register
   440 00000147 48BF-                   mov rdi, system_clock_post					;assign output format to rdi for printf output
   441 00000149 [D501000000000000] 
   442 00000151 E8(00000000)            call printf							;print system clock tics post-calculation
   443                                  
   444                                  ;========== Elapsed time ==========================================================================================================
   445                                  								;our values of clockspeed pre-calculations is in r12, clockspeed 
   446                                  								;post-calculations is in r14
   447                                  ;==== calculate elapsed time (tics) ====
   448 00000156 4D29E6                  sub r14, r12							;subtract the clockspeed pre-calculation from post-calc clockspeed
   449                                  								;this gives us our elapsed time
   450                                  								
   451                                  								;bc we are doing floating point calculations it is easier to place
   452                                  								;values onto the SSE registry and do the calculations there.
   453                                  
   454                                  ;==== calculate elapsed time (ns) ====				;our ns conversion formula is (clockspeed (in tics) * 10) / 26 = ns
   455 00000159 41BB0A000000            mov       r11, 10						;need to increase numerator by factor of 10, set up upcoming calc
   456 0000015F F2490F2AE3              cvtsi2sd xmm4, r11						;convert 10 into floating point and place onto xmm4
   457 00000164 F2490F2AEE              cvtsi2sd xmm5, r14						;convert our clockspeed (in tics) and place onto xmm5
   458 00000169 C5DD59E5                vmulpd   ymm4, ymm5						;multiply clockspeed (in tics) by factor of 10
   459 0000016D 41BB1A000000            mov       r11, 26						;int 26 onto r11 so that we may divide our value by(machine spd*10)
   460 00000173 F2490F2AEB              cvtsi2sd xmm5, r11						;convert 26 into floating point and place onto xmm5
   461 00000178 C5DD5EE5                vdivpd   ymm4, ymm5						;divide (tics * 10) by known cpu speed (2.6Ghz * 10) to get real ns	
   462 0000017C C5FD10C4                vmovupd  ymm0, ymm4						;output for nanoseconds ready on ymm0
   463                                  
   464                                  ;==== calculate elapsed time (sec) ====				;ns --> sec = ns/1billion
   465 00000180 41BB00CA9A3B            mov r11, 1000000000						;place 1billion onto r11 to prepare for floatpnt conversion on SSE
   466 00000186 F2490F2AEB              cvtsi2sd xmm5, r11						;converst 1billion into float number and place on xmm5
   467 0000018B C5DD5EE5                vdivpd ymm4, ymm5						;divide ns/1billion = elapsed time in seconds
   468 0000018F C5FD10CC                vmovupd ymm1, ymm4						;place elapsed time in seconds onto ymm1 for output
   469                                  
   470                                  ;==== output elapsed time ====					;elapsed time in tics sits on r14, ns on ymm0, sec on ymm1
   471 00000193 4831C0                  xor rax, rax
   472 00000196 4C89F6                  mov rsi, r14							;place elapsed time in tics on to rsi for output
   473 00000199 B801000000              mov rax, 1							;tell printf to find the first two numbers(ns/sec)on SSE(xmm0,xmm1)
   474 0000019E 48BF-                   mov rdi, elapsed_time						;format output for elapsed time in tics, ns, and seconds
   475 000001A0 [0F02000000000000] 
   476 000001A8 E8(00000000)            call printf							;output elapsed time in tics, ns, and seconds
   477                                  
   478                                  ;========== Output Results ========================================================================================================
   479                                  
   480                                  ;mov edi, 0x1f80						;See 'Future enhancements' in header
   481                                  ;ldmxcsr edi							;See 'Future enhancements' in header
   482                                  
   483                                  ;==== print output ====
   484 000001AD F2490F2DF2              cvtsd2si rsi, xmm10						;convert e^(x-Euler's) from FPU to int and place on int registry
   485 000001B2 C4C17B10C7              vmovsd xmm0, xmm15						;place sum on xmm0 in preparation for output (printf)
   486 000001B7 B801000000              mov  rax, 1							;tell printf to expect 1 FPU value on the upcoming print
   487 000001BC 48BF-                   mov  rdi, results	 					;prepare format for our values on printf
   488 000001BE [5701000000000000] 
   489 000001C6 E8(00000000)            call printf							;print x and e^x values to the terminal
   490                                  
   491                                  ;========== Return Sum to driver ==================================================================================================
   492                                  
   493 000001CB C4C17B10C7              vmovsd xmm0, xmm15						;Return sum to the driver program. Note: 'printf' in instructions
   494                                  								;  above has corrupted xmm0 so we must re-assign our sum before 
   495                                  								;  returning to the driver if we want the driver to recieve the sum
   496                                  
   497                                  ;=========== Now cleanup and return to the caller =================================================================================
   498                                  
   499 000001D0 415F                    pop r15								;Restore original value
   500 000001D2 415E                    pop r14								;Restore original value
   501 000001D4 415D                    pop r13								;Restore original value
   502 000001D6 415C                    pop r12								;Restore original value
   503 000001D8 415B                    pop r11								;Restore original value
   504 000001DA 415A                    pop r10								;Restore original value
   505 000001DC 4159                    pop r9								;Restore original value
   506 000001DE 4158                    pop r8								;Restore original value
   507 000001E0 59                      pop rcx								;Restore original value
   508 000001E1 5A                      pop rdx								;Restore original value
   509 000001E2 5E                      pop rsi								;Restore original value
   510 000001E3 5F                      pop rdi								;Restore original value
   511 000001E4 5D                      pop rbp								;Restore original value
   512                                  
   513 000001E5 C3                      ret								;Return to driver program (.cpp)
   514                                                                                                 
   515                                  ;========== End of program harmoniceuler.asm ======================================================================================
   516                                  
   517                                  ;========== Formula for computation derived =======================================================================================
   518                                  ; We need to calculate harmonic sum: 1 + 1/2 + 1/3 + ... + 1/n = x <--- user input
   519                                  
   520                                  ; Taylor series for eulers constant states that (1 + 1/2 + 1/3 + ... + 1/n) - ln(n) = eulers constant
   521                                  
   522                                  ; Now back to the original equation: 
   523                                  ;						1 + 1/2 + 1/3 + ... + 1/n = x
   524                                  ; subtract ln(n) from both sides       	       (1 + 1/2 + 1/3 + ... + 1/n) - ln(n) = x - ln(n)
   525                                  ; which is actually eulers constant		eulers_constant = x - ln(n)
   526                                  ;    on one side			
   527                                  ; Now we need to solve for n so lets		eulers_constant = x - ln(n)
   528                                  ;    get it alone on one side			
   529                                  ; first we need to add ln(n) to both sides	ln(n) + eulers_constant = x
   530                                  ; now we must subtract eulers from both sides	ln(n) = x - eulers_constant
   531                                  ; Finally to isolate n we raise both sides to e: e^(ln(n)) = e^(x-eulers_constant)
   532                                  
   533                                  ;   the 'e' and 'ln' cancel each other out so we get the final formula that we must use for our harmonic series computation:
   534                                  ;						n = e ^ ( x - eulers_constant)
